#include<iostream>
#include<vector>
using namespace std;
int main() {
	vector<int>arr;
	arr = { 1,2,3,4,5,6,7,8,9 };
	int p = 4;
//基本设计思路：
	//基本设计思想:因为左移后，原本位于数组前面的p个元素被挤到了倒数的p个位置
	//而原本在后面的n-p个元素则递补到了从第一个到第n-p个位置
	//若简单的将这p和n-p个元素看成两堆，我们思考直接将所有元素逆置，尽管这样处理的结果与题目所述的循环右移不一样
	//但是如果我们仅仅考虑这两堆元素的相对位置，会发现率先移动的p个元素确实出现在了最后p个位置，而被迫递补的n-p个元素也出现在了前面n-p个位置上
	//在采取上述思路进行逆置操作后，我们想要得到题目所述的左移操作，只需要调整顺序即可
	//而这里的调整顺序操作十分简单，将这两堆元素在内部分别在进行一次逆置即可
	int len = arr.size();
	//----------以下循环进行整个数组的逆置---------------------
	int temp = 0;
	int counter1 = 0;
	int counter2 = len - 1;
	for (int i = 0; i < len / 2; i++) {
		temp = arr[counter1];
		arr[counter1] = arr[counter2];
		arr[counter2] = temp;
		counter1++;
		counter2--;
	}
	//-----------------------------------------------------------

	//-----------以下循环实现前面n-p个元素的逆置-----------------
	//前n-p个元素的索引是从0~n-p-1
	counter1 = 0;
	counter2 = len-p-1;
	temp = 0;
	for (int i = 0; i < (len - p) / 2; i++) {
		temp = arr[counter1];
		arr[counter1] = arr[counter2];
		arr[counter2] = temp;
		counter1++;
		counter2--;
	}
	//------------------------------------------------------------

	//-----------以下循环实现后面p个元素的逆置-----------------
	//元素的索引是从n-p~n-1
	counter1 = len-p;
	counter2 = len-1;
	temp = 0;
	for (int i = 0; i < (p) / 2; i++) {
		temp = arr[counter1];
		arr[counter1] = arr[counter2];
		arr[counter2] = temp;
		counter1++;
		counter2--;
	}
	//------------------------------------------------------------

	for (int i = 0; i < len; i++) {
		cout << arr[i] << "  ";
	}

//说明时空复杂度
	//时间复杂度：该算法进行了遍历数组的操作所以时间复杂度为O(n)，虽然有多个循环，但不涉及循环嵌套，只是三个并列的循环，因此时间复杂度仍是O(n)
	//空间复杂度：该算法只涉及常数个变量，仅包括存放逆置元素的temp变量和一些计数器变量，因此空间复杂度为O（1）

//之前尝试的算法
    //以下注释掉的部分是最一开始的错误思路，我希望每次只移动一个元素到指定位置，接着移动该位置处原有的元素，不断重复此过程，直到所有元素都被移动到指定的位置
	//我事先考虑到由于存在遍历数组的操作，因此时间复杂度最起码也要O（n），而由于我这里采取了逐个元素移动的方法，可以将空间复杂度控制到O(1)
	//于是我编写了一下程序，在进行测试时出现了一定问题，经调试，发现如果n与p存在公约数则会出现下述算法并不能彻底完成左移任务（有被漏掉的元素）
	//在上述情境下有一个易于想到的解决方案就是再挑出没被移动的元素执行上述操作，最多只需要p个这样的过程总能实现题目要求，但仔细思考，会发现这样设计的时间复杂度会与p有关，且出现了循环的嵌套，时间复杂度不再是O(n)
	//还有一种常备想到的思路，是开一个大小一样的数组，一次把原数组中的元素，放在移动后的预期位置，可这样做的空间复杂度就不再是简单的O(1)
    /*int len = arr.size();
	int p = 4;
	int index = 0;
	int temp = 0;temp = arr[0];
	for (int i = 0; i < len; i++) {
		
		cout << "temp:" << temp << endl;
		index -= 4;
		if (index < 0) {
			index = 0 - index;
			index = len - index;

		}
		int temp2 = arr[index];
		arr[index] = temp;
		temp = temp2;
		cout << index << endl;
		
		cout << "temp2:" << temp2 << endl;
		

	}*/
	//for (int i = 0; i < len; i++) {
	//	cout << arr[i] << " ";

	//}
}